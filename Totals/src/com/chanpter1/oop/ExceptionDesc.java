package com.chanpter1.oop;
/**
 * ======================异常处理===========================
 * 1 Throwable是异常的基类，分为error和exception,在程序中我们只关注exception
 * 2 Exception分为编译期异常（受检）和运行时异常（非受检）
 * 3 异常会导致程序中断，无法继续执行
 * 4 在开发中，我们需要把可能出现异常的代码使用try语句块包裹起来
 * 5 处理异常可以让程序保持运行状态
 * 6 catch可以有多个，顺序为从子类到父类，小的放前边，大的放后边
 * 
 * 过程分析：
 * 	1 一旦产生异常，则系统会自动产生一个异常类的实例化对象
 *  2 此时如果存在了try语句，则会自动找到相匹配的catch语句执行；如果没有异常处理，则程序将退出，
 *  	并由系统报告错误
 *  3 所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功则表示由此catch进行处理
 * 
 *  throw和throws
 *  	throws关键字在方法上声明异常类的 作用是该方法内部不异常处理，交给方法调用处处理，
 *  			如果调用处不处理继续向上抛出直到jvm中断程序 报告错误信息
 *      throw关键字在方法内部使用表示手动抛出一个异常对象，因为从异常处理机制来看，所有的异常一旦产生之后，
 *      		实际上抛出的就是一个异常类的实例化对象，那么此对象也可以由throw直接抛出
 *  	
 *  	当代码出现异常，会产生异常对象（jdk代码或jvm）,把异常对象传入被匹配的catch中的异常对象变量
 *  
 *  异常处理的语法规则：
 *  	1：try语句不能单独存在，可以和catch,finally组成try...catch...finally,try...catch,try...finally
 *  		三种结构，catch语句可以有一个或多个，finally语句最多一个，try,catch,finally这三个关键字均
 *  		不能单独使用
 *  	2：try,catch,finally三个代码块中变量的作用于分别独立而不能相互访问
 *  	3：多个catch块的时候，java虚拟机会匹配其中一个异常类或其子类，就执行这个catch块，
 *  		而不会再执行别的catch块
 *  =================================自定义异常=================================================
 *  在java中，已经有许多的异常类的定义，但是我们在实际开发项目中，可能需要使用一些自己的异常类，那么通过继承
 *  	Exception类或已有的异常类的方式完成一个自定义异常类的操作
 *  
 *  NullPointerException
 *  	自定义异常的实现是提供构造方法
 *  	异常对象本身是没有实际功能，只是一个有意义的标识
 *  
 * 面试题：受检和非受检异常的区别
 * 		受检：受检异常，在编译期检查，在调用抛出此异常的方法时，必需显示的使用try&catch
 * 		非受检：非受检异常，在运行期检查，在调用抛出这个异常的方法时，可以不用显示使用try&catch
 * 		在使用自定义异常时，根据实际的业务要求，来决定使用哪个作为继承的父类
 * assert关键字，表示断言（断定是什么结果，跟测试相关） 测试与预期结果是否一致  了解
 * assert x==10:"结果不正确"; -ea
 * =================================================== 
 *  debug：调试         EXLIPSE IDE的优势
 *  		f5:单步跳入 进入本行代码中执行
 *  		f6:单步跳过  执行本行代码，跳到下一行
 *  		f7:单步返回  跳出方法
 *  		f8:继续，执行下一个断点   如果没有断点就执行到结束
 *  		ctrl+R:执行到光标所在的这一行
 * =================================================== 		
 *@version:
 *@Description: 
 *@author :衡晶
 *@date:2019年9月18日 下午6:43:27
 */
public class ExceptionDesc {

}
